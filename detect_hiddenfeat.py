"""Detect adv/clean from the hidden feature"""
from __future__ import absolute_import
from __future__ import print_function

import os
import argparse
from datasets import get_data
from models import get_model
import numpy as np
import sklearn.metrics
from sklearn.model_selection import StratifiedShuffleSplit, StratifiedKFold, train_test_split
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, roc_auc_score, roc_curve
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt

DATASETS = ['dr', 'cxr', 'derm']
ATTACKS = ['fgsm', 'bim', 'jsma', 'cw-l2', 'clean']
TEST_SIZE = {'dr': 0.7, 'cxr': 0.7, 'derm': 0.5}

def balance_data(X, y, sub_sample=False):  # assume that the positive samples is less than negative ones
    idx_pos, = np.where(y>0)
    idx_neg, = np.where(y<1)
    if sub_sample:
        idx_neg = np.random.choice(idx_neg, len(idx_pos))
    else:  # over sample
        idx_pos = np.random.choice(idx_pos, len(idx_neg))
    idx_resample = np.concatenate([idx_neg, idx_pos])
    return X[idx_resample], y[idx_resample]


def detect(args):
    assert args.dataset in ['mnist', 'cifar-10', 'svhn', 'dr', 'cxr', 'derm'], \
        "Dataset parameter must be either 'mnist', 'cifar-10', 'svhn', 'dr', 'cxr', or 'derm'"
    assert args.attack in ['fgsm', 'bim', 'jsma', 'deepfool', 'pgd', 'ead', 'cw-l2', 'cw-lid'], \
        "Attack parameter must be either 'fgsm', 'bim', 'jsma', 'deepfool', " \
        "'pgd', 'ead', 'cw-l2', 'cw-lid'"

    # load feature/label data
    _, _, cX_test, cy_test = get_data(args.dataset, onehot=False, load_feat='clean')  # clean feat
    _, _, aX_test, ay_test = get_data(args.dataset, onehot=False, load_feat=args.attack)  # attack feat

    # balance data
    cX_test, cy_test = balance_data(cX_test, cy_test)  # balance over positive/negative examples
    aX_test, ay_test = balance_data(aX_test, ay_test)  # balance over positive/negative examples
    X = np.concatenate([cX_test, aX_test])
    y = np.concatenate([np.zeros(len(cX_test)), np.ones(len(aX_test))])

    # # load testing data
    # _, _, test_idx = np.load('data/split_%s.npy' % args.dataset)  # generated by "extract_features.py -d dataset -a clean"
    # feat_clean = np.load('data/feat_%s_clean.npy' % args.dataset)
    # feat_adv = np.load('data/feat_%s_%s.npy' % (args.dataset, args.attack))
    # feat_clean, feat_adv = feat_clean[test_idx], feat_adv[test_idx]
    # _, _, _, is_positive = get_data(args.dataset, onehot=False)
    #
    # # balance data through under-sampling
    # idx_pos, = np.where(is_positive>0)
    # idx_neg, = np.where(is_positive<1)
    # idx_neg_resample = np.random.choice(idx_neg, len(idx_pos))
    # idx_neg_resample2 = np.random.choice(idx_neg, len(idx_pos))
    # X = np.concatenate([feat_clean[idx_pos], feat_clean[idx_neg_resample], feat_adv[idx_pos], feat_adv[idx_neg_resample2]])
    # y = np.concatenate([np.zeros([len(idx_pos)+len(idx_neg_resample)]), np.ones([len(idx_pos) + len(idx_neg_resample2)])])
    # print('Total Samples: %d = %d pos_clean + %d pos_adv + %d neg_clean + %d neg_adv' %
    #       (len(y), len(idx_pos), len(idx_pos), len(idx_neg_resample), len(idx_neg_resample2)))

    # do PCA
    do_pca = True
    if do_pca:
        pca = PCA(20, True)
        X_pca = pca.fit_transform(X)
        print('PCA explanation of variances:', (pca.explained_variance_ratio_))
        plt.scatter(X_pca[y<1, 0], X_pca[y<1, 1])
        plt.scatter(X_pca[y>0, 0], X_pca[y>0, 1])
        plt.show()

    # train-test split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=TEST_SIZE[args.dataset])
    clf = SVC(gamma=2.8, probability=True)  # RandomForestClassifier(30)  # SVC(gamma=2.8, probability=True)
    clf.fit(X_train, y_train)
    print('Acc:', accuracy_score(y_test, clf.predict(X_test)))
    print('AUC:', roc_auc_score(y_test, clf.predict_proba(X_test)[:, 1]))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-d', '--dataset',
        help="Dataset to use",
        required=True, type=str
    )
    parser.add_argument(
        '-a', '--attack',
        help="Attack to use train the discriminator; either 'fgsm', 'bim-a', 'bim-b', 'jsma', 'cw-l2'",
        required=True, type=str
    )


    # args = parser.parse_args()
    # detect(args)

    for ds in ['derm', 'dr', 'cxr']:
        for atk in ['fgsm', 'bim', 'pgd']:
            argv = ['-d', ds, '-a', atk]
            print('\n$> ', argv)
            args = parser.parse_args(argv)
            detect(args)

